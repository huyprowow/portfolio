/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 .\public\assets\Fanny\Fanny.glb -o .\src\components\canvas\Character\Character.tsx 
*/

import { Assets } from '@/helpers/assetMap'
import { Controls } from '@/helpers/constants'
import { useBoundStore } from '@/store/store'
import { useKeyboardControls } from '@react-three/drei'
import { useFrame, useLoader, useThree } from '@react-three/fiber'
import { CuboidCollider, RapierRigidBody, RigidBody, euler, quat, vec3 } from '@react-three/rapier'
import { useEffect, useRef } from 'react'
import * as THREE from 'three'
import { MMDLoader } from 'three-stdlib'
import Cameras from './Cameras/Cameras'

const Character = (props) => {
  const group = useRef()
  const nodes = useLoader(MMDLoader, Assets.CHARACTER)
  const setCharacter = useBoundStore((state) => state.setCharacter)
  const rigidBody = useRef<RapierRigidBody>(null)
  const { controls, camera } = useThree((state) => state)
  let rotateAngle = new THREE.Vector3(0, 1, 0)
  let rotateQuaternion = new THREE.Quaternion()
  const lookAt = vec3({ x: -5, y: 15, z: 0 })
  let onAir = false

  const { forward, back, left, right, jump }: any = useKeyboardControls<Controls>((state: any) => state)
  console.log({
    forward,
    back,
    left,
    right,
    jump,
  })
  useEffect(() => {
    setCharacter(nodes)
  }, [])

  //tinh toan huong bu cua nhan vat
  /*               w
        pi/4   0(offset) -pi/4
  (a)  pi/2                     -pi/2 (d)
        3pi/4      pi    -3pi/4
                  s                  */
  const directionOffset = ({
    forward,
    left,
    right,
    backward,
  }: {
    forward: Boolean
    left: Boolean
    right: Boolean
    backward: Boolean
  }) => {
    let directionOffset = 0
    if (forward) {
      if (left) {
        directionOffset = Math.PI / 4 //w+a
      } else if (right) {
        directionOffset = -Math.PI / 4 //w+d
      }
    } else if (backward) {
      if (left) {
        directionOffset = (3 * Math.PI) / 4 //s+a
      } else if (right) {
        directionOffset = (-3 * Math.PI) / 4 //s+d
      } else {
        directionOffset = Math.PI //s
      }
    } else if (left) {
      directionOffset = Math.PI / 2 //a
    } else if (right) {
      directionOffset = -Math.PI / 2 //d
    }
    return directionOffset
  }

  useFrame((state, delta) => {
    if (rigidBody.current) {
      const position = vec3(rigidBody.current.translation())
      const quaternion = quat(rigidBody.current.rotation())
      const eulerRot = euler().setFromQuaternion(quat(rigidBody.current.rotation()))

      if (forward || back || left || right) {
        const desiredQuaternion = directionOffset({ forward, left, right, backward: back })
        quaternion.slerp(rotateQuaternion.setFromAxisAngle(rotateAngle, desiredQuaternion), 0.2)
        // While Rapier's return types need conversion, setting values can be done directly with Three.js types
        rigidBody.current.setRotation(quaternion, true)
      }

      if (jump) {
        rigidBody.current.applyImpulse(new THREE.Vector3(0, 1000, 0), true) // Sử dụng applyForce cho nhảy
      }
      rigidBody.current.setTranslation(position, true)
      camera.lookAt(position.add(lookAt))
    }
  })
  return (
    <group ref={group} {...props} dispose={null} position={[-8, 9, 7]} rotation={[0, 0, 0]} scale={1}>
      <mesh>
        <Cameras />
        <RigidBody colliders={false} ref={rigidBody} lockRotations={true}>
          <primitive object={nodes} />

          {/* <group name='Root_Scene'>
          <group name='RootNode'>
            <group name='Armature' scale={100} position={[0, 0, -3.7]}>
              <primitive object={nodes.mixamorigHips} />
            </group>

            <skinnedMesh
              name='body_0'
              geometry={nodes.body_0.geometry}
              material={materials['fanny_skin07_high_d_03mat.001']}
              skeleton={nodes.body_0.skeleton}
              scale={100}
            />
            <skinnedMesh
              name='weapon_0'
              geometry={nodes.weapon_0.geometry}
              material={materials['fanny_skin07_high_d_02mat.001']}
              skeleton={nodes.weapon_0.skeleton}
              scale={100}
            />
            <skinnedMesh
              name='body_1'
              geometry={nodes.body_1.geometry}
              material={materials['fanny_skin07_high_d_01mat.001']}
              skeleton={nodes.body_1.skeleton}
              scale={100}
            />
            <skinnedMesh
              name='m_body_1001'
              geometry={nodes.m_body_1001.geometry}
              material={materials['fanny_skin07_high_d_01mat.001']}
              skeleton={nodes.m_body_1001.skeleton}
              scale={100}
            />
          </group>
        </group> */}
          <CuboidCollider
            args={[5, 10, 5]}
            position={[0, 10, 0]}
            mass={50}
            friction={1.0}
            restitution={0}
            linearDamping={1}
            angularDamping={1}
          />
        </RigidBody>
      </mesh>
    </group>
  )
}
export default Character
